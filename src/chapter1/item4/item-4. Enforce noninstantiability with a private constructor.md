인스턴스화를 막고싶다면 private 생성자를 사용하라
## 유틸리티 클래스
- `정적 메서드`, `정적 필드`와 같은 `정적 멤버`만 담은 클래스를 일컫는 말
	- Java에서 제공하는 라이브러리에서도 이러한 클래스를 찾아볼 수 있음
		- `java.lang.Math`, `java.util.Arrays`와 같이 원시 타입, 배열 관련 메서드를 모아놓은 클래스
		- `java.util.Collections`와 같이 특정 인터페이스를 구현하는 클래스의 객체를 생성해주는 `정적(또는 정적 팩터리) 메서드`를 모아놓은 클래스
	- 이외에도 final 클래스와 관련한 메서드를 모아놓을 때도 사용됨
		- final 클래스를 상속해 하위 클래스에 메서드를 추가하는건 불가능하기 때문
### 유틸리티 클래스의 인스턴스화 막기
- 유틸리티 클래스는 인스턴스를 만들어 쓰는 것을 목적으로 설계하지 않음
	- 다만, 개발자가 생성자를 명시해놓지 않으면 컴파일러가 기본 생성자를 자동으로 만듦
	- 해당 클래스를 사용하는 사용자는, 이 생성자가 자동 생성된 것인지 알 수 없음
- 이를 막기위해 `유틸리티 클래스`를 **`추상 클래스`** 로 선언하는 경우가 있는데, 이것만으로는 인스턴스화를 막을 수 없음
	- 이를 상속한 클래스를 만들어 인스턴스화 하면 되기 때문
	- 오히려 `abstract` 키워드를 보고 `상속해야하는 클래스로 오해`할 수 있기 때문에 **위험**
#### private 생성자 추가하기
```java
public class UtilityClass {
	// 기본 생성자가 만들어지는 것을 막음
	private UtilityClass() {
		// AssertionError를 던지는 것이 필수는 아니지만, 실수로도 이를 호출하지 않도록 해줌
		throw new AssertionError();
	}
}
```
- 명시적으로 `private 생성자`를 추가해주면, `컴파일러가 기본 생성자를 만들지 않고` `외부`에서도 해당 `생성자를 접근할 수 없기 때문에` 클래스의 인스턴스화를 막을 수 있다. 
- 또한 이 방법은 클래스를 상속하지 못하게 하는 부수효과도 갖추고 있다.
	- 모든 클래스의 생성자는 명시적이든 묵시적이든 상위 클래스의 생성자를 호출한다.
	- 하지만 상위 클래스인 `UtilityClass`의 생성자가 `private`이므로 이를 수행할 수 없게되고, 상속이 불가능해진다.