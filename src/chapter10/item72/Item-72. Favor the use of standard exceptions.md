표준 예외를 사용하라
- Java 라이브러리에서는 충분한 수의 예외를 제공하고 있으므로, 가능한 이를 재사용하는것이 좋음
## 표준 예외를 재사용할 경우 이점
### API의 학습 난이도 완화
- API를 사용하는 사용자들이 익히고 사용하기 쉬워짐
### 성능 최적화
- *사용되는 예외 클래스가 적을수록* `메모리 사용량 감소` 및 `클래스 적재 시간 감소`
## 주로 재사용되는 예외
### IllegalArgumentException
- 함수 호출자가 `인수`로 `부적절한 값`을 넘길 때 던지는 예외
- ex) 반복 횟수를 의미하는 매개변수에 음수를 넘기는 경우
### IllegalStateException
- *대상 객체의 상태 때문에* `메서드 호출이 적법하지 않을때` 던지는 예외
- ex) 제대로 초기화되지 않은 객체를 사용하려 할 경우
#### 메서드 관련 예외 주의사항
- 다만, 메서드가 던지는 예외 중 다음과 같이 특수한 경우는 따로 구분해서 사용
	- *null을 허용하지 않는 메서드*에 `null 값`을 넘긴 경우, `NullPointerException`
	- 어떠한 시퀀스의 허용 범위를 넘는 값을 넘긴 경우, `IndexOutOfBoundsException`
### ConcurrentModificationException
- *`단일 스레드 환경`에서 사용하고자 설계한 객체*를 여러 `스레드가 동시에 수정`할 때 던지는 예외
	- 실제로 *동시 수정을 안정적으로 감지하는 것은 불가능*하므로, `이러한 문제가 생길 수 있음`을 알려주는 힌트 정도의 역할을 하는 예외
### UnsupportedOperationException
- 클라이언트가 요청한 동작을 해당 객체가 지원하지 않을 때 던지는 예외
	- 보통 *구현하려는 인터페이스의* `메서드 일부를 구현할 수 없을 때` 사용
		- ex) 원소의 삽입만 가능한 List 구현체에 remove를 호출하는 경우
## 추상 수준의 예외 클래스를 직접 재사용하지 말것
- `Exception`, `RuntimeException`, `Throwable`, `Error`와 같은 클래스는 `추상 클래스라고 간주`하고 사용하길 권장
	- 위 클래스들은 *메서드들이 던질 수 있는* `다른 예외들의 상위 클래스`기 때문에, `안정적으로 테스트할 수 없음`
## 표준 예외 재사용시 주의 사항
- 사용하려는 표준 예외의 `API 문서를 확인`해, `어떠한 상황`에서 던져지는 예외인지 확인할 것
	- 즉, *예외 이름 뿐만 아니라* `예외가 던져지는 맥락` 역시 부합할 때 재사용해야 함
- 필요하다면 `표준 예외를 확장`해도 좋으나, `예외는 직렬화 할 수 있다는 점`을 유의할 것
	- 즉, 직렬화와 관련해 `버전 별 호환 문제` 및 `serialVersionUID`와 같은 요소들을 관리해야 하는 불편함이 존재
### 예외를 선택하는 기준
- 앞서 설명한 예외들의 '사용 기준' 이 `상호 배타적이지 않아`, 즉 `이 예외에도 사용 가능하고, 저 예외도 사용 가능한` 경우가 종종 발생해 어떤 예외를 선택할 지 어려울 수 있음
- ex) 인수로 건넨 수 만큼의 카드를 뽑는 메서드에 남아있는 카드 수 보다 큰 값을 건넨다면?
	- `인수의 값이 크다`는 관점이라면 `IllegalArgumentException`
	- `남아있는 카드 수가 너무 적다`는 관점이라면 `IllegalStateException`
- 이러한 경우 일반적으로 다음과 같이 결정
	- *인수 값이 무엇이든* 어차피 실패했을거라면 `IllegalStateException`
	- 그렇지 않다면 `IllegalArgumentException`