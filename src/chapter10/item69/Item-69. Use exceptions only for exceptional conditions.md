예외는 진짜 예외 상황에만 사용하라
## 일상적인 제어 흐름용으로 쓰지 말 것
### 예외를 잘못 사용한 예
```java
try {
	int i = 0;
	while(true) {
		range[i++].climb();
	}
} catch (ArrayIndexOutOfBoundsException e) {
}
```
- 위 코드는 *잘못된 추론 때문에* `예외를 통한 루프문 탈출`로 성능을 끌어올리고자 한 예시
	- `JVM`은 *배열에 접근할 때 마다* `배열의 경계를 넘지 않는지 검사`하는데, 일반적인 루프문의 `종료 테스트에서도 이를 검사`하기 때문에(ex. for문의 `i < array.length`) `중복적인 검사가 발생한다고 판단`한 것
	- 따라서 종료 테스트에서 *배열 경계를 검사하던 것을 `생략`* 해 성능을 개선하고자 한 경우임
#### 추론이 잘못된 이유
1. `예외`는 `예외적인 상황에서 사용`하기 위해 설계된 것으로, `JVM을 구현하는 측`에서 `명시적인 테스트`만큼 빠르게 만들 이유가 없음
	- 즉, 최적화에 별로 신경쓰지 않음
2. 코드를 `try-catch` 블록 안에 넣으면, *JVM이 수행할 수 있는* `최적화가 제한`됨
3. 배열을 순회하는 `표준 관용구`는 이러한 중복 검사를 수행하지 않고, JVM에서 최적화하여 없애줌
```java
// 표준적인 배열 순회 관용구
for (Mountain m : range) {
	m.climb();
}
```
#### 올바르지 않은 예외 사용으로 인한 해악
- 코드 가독성 하락, 성능 감소 뿐만 아니라 `올바르지 않게 동작`할수도 있음
	- `흐름 제어를 위해 사용한 예외`가 *반복문 내에서 발생한* `버그를 숨겨` 디버깅을 힘들게 만듦
	- 가령 위 예시 코드의 반복문 내부에서 `다른 배열을 사용하는 메서드`를 호출했다가, 해당 메서드에서 `ArrayIndexOutOfBoundsException`이 발생해도 `정상적인 반복문 종료로 오해`하고 넘어갈 수 있음
### 교훈 - 올바르게 예외를 사용하라
- 자바 플랫폼은 꾸준히 개선되고 있으니, 과하게 머리를 써 최적화를 하다가 성능 우위는 오래가지도 않고, 숨겨진 버그 및 유지보수 문제가 발생할 수 있음
### API 설계시 주의할 점
- 잘 설계된 API라면, `클라이언트`가 *정상적인 제어 흐름에서* `예외를 사용할 일이 없어야 함`
- 만약 `상태 의존적인 메서드`를 제공하는 클래스라면, 상태를 확인할 수 있는 `상태 검사 메서드` 역시 제공해야 함
	- ex) `Iterator` 인터페이스는 `next`와 `hasNext`를 제공하고 있으며, 이를 통해 아래와 같은 `표준 for 관용구`를 사용할 수 있음
	```java
		for (Iterator<Foo> i = collection.iterator(); i.hasNext(); ) {
			Foo foo = i.next();
		}
	```
- `상태 검사 메서드` 대신에, 올바르지 않은 상태일 경우 `빈 옵셔널` 또는 `null`과 같은 `특수한 값을 반환`하는 메서드를 쓸 수도 있음
	- 이들 중 한 방법을 선택하는 지침은 다음과 같음
		1. 외부 동기화 없이 `여러 스레드가 동시 접근 가능`하거나, `외부에 의해 상태가 변할 수 있는` 경우
			- `옵셔널` 또는 `특정 값` 사용
				- `상태 검사` - `상태 의존 메서드 호출` 사이에 상태가 변할 수 있기 때문
		2. *성능이 중요하며*, `상태 검사 메서드`가 `상태 의존적 메서드 작업의 일부`를 `중복 수행`하는 경우
			- `옵셔널` 또는 `특정 값` 사용
		3. 그 외의 경우
			- `상태 검사 메서드` 방식이 조금 더 나음
				- 가독성이 높고, 잘못 사용할 경우 발견이 쉽기 때문
# 핵심 정리
- `예외`는 `예외 상황에 쓸 의도로 설계`되었으므로, *정상적인 제어 흐름*에서 `사용해서는 안 됨`
- 또한, 이를 `프로그래머에게 강요하는 API`를 *만들어서도 안 됨*