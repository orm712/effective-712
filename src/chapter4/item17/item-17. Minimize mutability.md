변경 가능성을 최소화하라
# 불변 클래스의 이점
## 불변 클래스
- 인스턴스의 내부 값을 수정할 수 없는 클래스
- `String`, `박싱 클래스`, `BigInteger`, `BigDecimal`과 같은 클래스가 대표적
- `불변 클래스`는 *가변 클래스에 비해* 설계, 구현, 사용하기 쉽고, 오류 발생 가능성이 적으며 보안적으로도 안전함
### 불변 클래스의 다섯 가지 규칙
#### 객체의 상태를 변경하는 변경자를 제공하지 않는다
#### 클래스를 확장 불가능하게 만든다
- 이를 통해 *부주의하거나* `악의적인 클래스`가 객체의 상태가 변경된 것처럼 동작하는 것을 막음
- 클래스의 `확장을 막는 방법`은 다음과 같음
	1. 클래스를 `final로 선언`하기
	2. `모든 생성자`를 `private`(또는 `package-private`)로 만들고, `public 정적 팩터리` 제공하기
		- 패키지 밖의 클라이언트 측에서는 확장이 불가능해지므로, `package-private` *내부 클래스를 마음껏 만들어 사용*할 수 있는 `유연함`을 제공
#### 모든 필드를 final로 선언한다
- 이를 통해 명확히 의도를 드러낼 수 있음
- 새로 생성된 인스턴스를 동기화 없이 스레드 간 전달할 때 문제 없이 동작함을 보장하는데도 중요
- 이와 달리 `BigInteger`나 `BigDecimal`의 메서드들을 재정의할 수 있게 설계됨
	```java
	public static BigInteger safeInstance(BigInteger val) {
		// 인자로 받은 val이 진짜 BigInteger인지 확인하고, 그렇지 않다면 방어적 복사 수행
		return val.getClass() == BigInteger.class ?
			val : new BigInteger(val.toByteArray());
	}
	```
	- 따라서 `이들의 인스턴스`를 `인수`로 받을 시 `하위 클래스의 인스턴스`인지 `확인`하고, *만약 맞다면* 이들을 `가변이라고 가정`하고 `방어적 복사`를 거쳐 사용해야 함
- 추가로 위 조건이 너무 빡빡하다면, 이를 '`외부에 노출된 값`만 변경하지 못한다'로 완화해 사용할 수도 있음
	- 이를 통해 내부에 *`자주 요청`되거나, `계산 비용이 큰 값`* 을 `캐싱`해두고 쓰기도 함
#### 모든 필드를 private로 선언한다
- 필드가 참조하는 가변 객체를 직접 접근해 수정하는 것을 막음
- `public final` 필드로 선언할 경우 추후 내부 구현 수정이 어려워짐
#### 가변 컴포넌트에 대한 외부의 접근을 막는다
- 즉, 가변 객체를 참조하는 필드가 있다면, 해당 객체에 대한 참조를 클라이언트에서 얻지 못하도록 해야 함
- 해당 필드는 클라이언트에서 제공한 객체 참조를 가리켜선 안되며, 접근자가 해당 필드를 반환해서도 안 됨
	- 즉, `방어적 복사`가 필요
### 예시 - 복소수 클래스
- 예시의 복소수 클래스는 복소수 클래스를 반환 타입으로 갖는 메서드에 대해, *인스턴스 스스로를 수정한 객체가 아닌* `새로운 객체`를 만들어 **반환**함
	- 이러한 형태를 `함수형 프로그래밍`이라 함
	- 인스턴스 `스스로의 상태를 수정`하는 방식은 `절차적/명령형 프로그래밍`이라 함
	- 함수 이름이 동사(ex. `add`)가 아닌 전치사(ex. `plus`)를 사용하는 것이 이들의 차이를 드러냄
### 불변 객체의 장점
#### 생성 시점의 상태를 파괴까지 간직하는 **단순**한 객체
- 따라서 모든 생성자가 `클래스 불변성`([class invariants](https://en.wikipedia.org/wiki/Class_invariant))을 만족하면, `해당 클래스의 객체`는 영원히 `불변`으로 남음
- `가변 클래스`는 *변경자가 일으키는 `상태 전이`* 가 `문서화되어 있지 않는 한` 믿고 쓰기 힘듦
#### 근본적으로 스레드 안전하다
- 따라서 `동기화가 필요하지 않으며`, `자유롭게 공유`할 수 있음
- 또한, *여러 스레드간*에 `동시에 사용`해도 `훼손되지 않음`
- 이러한 특징을 최대한 활용하려면, `한 번 만든 인스턴스`를 `재사용`해야 함
	- 가장 쉬운 방법은 자주 쓰이는 값을 `public static fianl(상수)`로 제공하는 것
	- 또는, 인스턴스를 `캐싱`해 제공하는 `정적 팩터리` 방식을 사용할 수도 있음
		- `Integer`와 같은 박싱 클래스, `BigInteger` 등의 클래스에 존재
			- ex) `Integer.valueOf(int)`
- `인스턴스의 공유`는 `메모리 사용량`, `가비지 컬렉션 비용 감소`에 **이점**
- 가변 클래스와 달리, *`방어적 복사`를 하는 번거로움*도 없음
	- 복사해도 원본과 동일하기 때문에 복사가 의미 없음
#### 불변 객체간 내부 데이터 공유가 가능함
- 값의 `부호(int)`와 `크기(int[])`를 갖는 `BigInteger`의 경우, 부호가 반대인 값을 반환하는 `negate()` 메서드를 통해 생성한 `BigInteger`는 `원본의 크기`를 그대로 `공유`함
	- 즉, 새롭게 생성된 `BigInteger`의 `크기`는 `원본의 크기 배열`을 `참조`함
#### 객체의 구성요소로 불변 객체를 사용할 시 불변식 유지가 훨씬 쉬움
- 예를 들어, `Map의 키`나 `Set의 원소`로 불변 객체를 쓰면 값이 바뀔 염려가 없어 불변식이 무너지지 않기 때문
#### 불변이라는 특성을 통해 실패 원자성을 제공
- `실패 원자성`: 메서드에서 예외가 발생해도, (메소드 호출 전과 동일한) 유효한 상태를 유지하는 성질
### 불변 클래스의 단점
#### 각 고유한 값에 대해, 별도의 객체를 만들어야 함
- 즉, 값의 `경우의 수가 많다면` 이들을 만드는데 `많은 비용`이 듦
- 가령 `100만 비트`짜리 `BigInteger`에서 비트를 **하나**만 바꾼다면, *원본과 고작 한 비트만 다른* `또다른 100만 비트짜리 인스턴스`를 만들어야 함
- 이는 `객체 완성까지의 단계가 많고`, 그 과정에서 `만들어진 객체들이 모두 버려질`수록 심각해짐
##### 대처 방법
1. 다단계 연산들을 예측해 `기본 기능`으로 `제공`
	- ex) `BigInteger`에서는 `모듈러 지수`와 같이 `여러 단계를 거치는 연산`의 속도를 높여주는 `가변 동반 클래스`를 `package-private`으로 두고 내부적으로 활용
2. `가변 동반 클래스`를 `public으로 제공`하기
	- ex) `String`의 `가변 동반 클래스`인 `StringBuilder(이전에는 StringBuffer)`
# 핵심 정리
- `클래스`는 *(필요하지 않은 이상)* `불변`이어야 함
	- 이를 통해 얻는 실보다 득이 많음
- `단순한 값 객체`는 `항상 불변`으로 만들 것
- `무거운 값 객체`(ex) BigInteger, String)도 *가능하다면* `불변으로 만드는 것이 좋음`
	- 성능 등의 이유로 힘들다면, `public 가변 동반 클래스`를 제공할 것
- 만약 *불변으로 만들 수 없다면*, `변경 가능한 부분`을 `최소화` 할 것
	- 객체가 갖는 *상태의 경우의 수를 줄이면*, `예측이 쉬워`지고 `오류 가능성이 줄어듦`
	- 따라서, *변경이 필요한 필드 외에는* `final로 선언`할 것
- `생성자`는 `불변식 설정`과 `초기화`가 **`완전히 끝난 객체`** 를 `생성`해야 함
	- 이유 없이 *`생성자`, `정적 팩터리`외의* `초기화 메서드`를 **공개하지 말 것**
	- 객체를 재활용하고자 `상태를 초기화하는 메서드`도 성능 이점이 거의 없음