일반적으로 통용되는 명명 규칙을 따르라
## Java의 명명 규칙
- Java 언어 명세([Java Language Specification 6.1](https://docs.oracle.com/javase/specs/jls/se7/html/jls-6.html#jls-6.1))에 명명 규칙들이 정립되어 있음
### 철자 규칙
- `패키지`, `클래스`, `인터페이스`, `메서드`, `필드`, `타입 변수`의 이름과 관련된 규칙
- *이를 어긴 API*는 `사용하기 어렵고`, `유지보수성도 저하`됨
#### 패키지 / 모듈
- 각 요소를 `점으로 구분`하여 `계층적`으로 지을 것
	- 요소들은 모두 `소문자 알파벳`, `(드물게) 숫자` 로 이루어짐
- *조직 외부에서도 사용*될 예정이라면, 조직의 `인터넷 도메인`을 역순으로 사용
	- ex) `edu.cmu`, `com.google`
	- 예외적으로, `표준 라이브러리` 및 `옵셔널 패키지`는 `java` 와 `javax`로 시작
- `패키지 이름의 나머지`는 *해당 패키지를 설명하는* `하나 이상의 요소`로 구성
	- 각 요소는 `8자 이하의 짧은 단어`로, *가능한 `약어를 사용`* 할 것
		- ex) `utilities` -> `util`
	- 여러 단어로 구성된 경우, `awt(Abstract Window Toolkit)`와 같이 각 단어의 첫 글자만 따서 사용할 수 있음
- *많은 기능을 제공할 경우*, `계층을 나누어` 더 많은 요소로 구성해도 됨
	- ex) `java.util`의 밑에는 `java.util.concurrent.atomic`과 같이 더 많은 패키지들이 존재
#### 클래스 / 인터페이스
- 아래 명명 규칙들은 `열거 타입`과 `애너테이션`에도 적용됨
- `하나 이상의 단어`로 이루어지며, 각 단어는 `대문자로 시작`
- 단어들의 `첫 글자만 딴 약어`, max 와 같이 `통용되는 줄임말`를 *제외*하고는 줄여쓰는 것을 자제할 것
	- 보통 약자는 `첫 글자만 대문자`로 하는 경우가 많음
	- `HttpUrl`과 같이 `약자가 혼합`되어도 `각 약자의 시작과 끝`을 알 수 있기 때문
#### 메서드 / 필드
- *클래스 명명 규칙과 비슷하나*, `첫 글자를 소문자`로 씀
	- *첫 단어가 약자일 경우*, `단어 전체가 소문자`여야 함
	- ex) `JSONParser`🚫`jsonParser`✅
- 단, **`상수 필드`** 는 예외로, 구성하는 `모든 단어를 대문자`로 쓰며 단어 사이를 `밑줄로 구분`함
	- ex) `NEGATIVE_INFINITY`
	- `상수 필드`: `기본 타입` 또는 `불변 참조타입`의 `static final 필드` / `불변인 객체`를 가리키는 `static final 필드`
#### 지역 변수
- `멤버 이름`과 비슷한 명명 규칙이 적용되나, `약어 사용을 허용`함
	- 약어를 사용해도, `문맥`을 통해 의미를 유추하기 쉽기 때문
- `입력 매개변수`도 `지역변수`로 간주되나, 일반 지역변수보다는 신경써서 명명해야 함
#### 타입 매개변수
- 보통 한 문자로 표현
	- 임의의 `타입`인 경우 `T`
	- `컬렉션 원소`의 타입인 경우 `E`
	- 맵의 `키/값`인 경우 `K`, `V`
	- `예외`인 경우 `X`
	- 메서드의 `반환 타입`에는 `R`
	- 이 외의 경우에는 `T`, `U`, `V`, `T1`, `T2`, `T3` 등을 사용
### 문법 규칙
- 철자 규칙에 비해 더 유연하나, 논란도 많음
#### 패키지 / 모듈
- 규칙 없음
#### 클래스 / 인터페이스
##### 클래스
- 🚫객체를 생성할 수 있는 경우, `단수 명사`나 `명사구`를 사용
	- ex) `Thread`, `PriorityQueue`
- ✅객체를 생성할 수 없는 경우, `복수형 명사`를 사용
	- ex) `Arrays`, `Collections`
##### 인터페이스
- `클래스와 똑같이` 짓거나, `able` 또는 `ible`로 끝나는 `형용사`를 사용
	- ex) `Collection`, `Comparator`
	- ex) `Runnable`, `Iterable`, `Comparable`
##### 애너테이션
- `명사`, `동사`, `전치사`, `형용사`를 두루두루 사용
	- ex) `Singleton`, `Inject`, `Resource`, `Transactional` 
#### 메서드
- 어떤 `동작을 수행`하는 경우 `동사`나 `(목적어를 포함한) 동사구`를 사용
	- ex) `append`, `drawImage`
- `boolean`을 반환하는 경우 `is` 또는 `has`로 시작하고 `명사`/`명사구`/`형용사로 기능하는 단어 또는 구`로 끝냄
	- ex) `isDigit`, `isProbablePrime`, `isEnabled`
- *반환 타입이 boolean이 아니거나*, 인스턴스의 `속성을 반환`하는 경우 `명사`/`명사구`/`get으로 시작하는 동사구`를 사용
	- ex) `size`, `hashCode`,`getTime`
- `get`으로 시작하는 형태는 주로 `JavaBeans` 명세에 뿌리를 둠
	- 이러한 명명 방식을 사용하는 `툴과 어우러지는 코드`거나, 한 속성의 `게터/세터를 제공`할 때 적합
##### 특별 케이스
- `다른 타입의 다른 객체`를 반환하는 인스턴스 메서드는 `toType`과 같은 형태를 사용
	- ex) `toArray`, `toString`
- 객체의 내용을 `다른 뷰`로 보여주는 메서드는 `asType`과 같은 형태를 사용
	- ex) `asList`
- 객체의 값을 `기본 타입 값`으로 반환하는 경우 `typeValue`와 같은 형태를 사용
	- ex) `intValue`
- `정적 팩터리`의 경우 `from`, `of`, `valueOf`, `instance`, `getInstance`, `newInstance`, `getType`, `newType`을 흔히 사용
#### 필드
- *API가 잘 설계되었다면*, 필드가 직접 노출될 일이 거의 없어 덜명 확하고 덜 중요
- `boolean 타입`의 필드는 보통 `접근자 메서드`에서 앞 단어를 뺀 형태
	- ex) `isInitialized` -> `initialized`
- `그 외의 타입`의 필드는 `명사`나 `명사구`를 사용
	- ex) `height`, `digits`, `bodyStyle`
# 핵심 정리
- 표준 명명 규칙을 체화하여 자연스럽게 사용할 수 있도록 할 것
- `철자 규칙`은 `직관적`이나, `문법 규칙`은 더 `복잡하고 느슨`