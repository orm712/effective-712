# Item28. 배열보다는 리스트를 사용하라

## 배열과 제네릭의 차이점
### 배열
- 공변(convariant)
  - Sub가 Super의 하위 타입이라면 배열 Sub[]는 배열 Super[]의 하위 타입이다.
  - 즉, 함께 변한다.
  - 그렇다고 해서 배열이 옳은 것이 아니다.
- 실체화 가능
  - 배열은 런타임에 자신이 담기로 한 원소의 타입을 인지하고 확인한다.
### 제네릭
- 불공변(invariant)
  - `List<Sub>`와 `List<Super>`는 아무 관계가 없다.
- 실체화 불가능
  - 제네릭은 타입 정보가 런타임에는 소거된다.
    - 원소 타입을 컴파일 시에만 검사하며 런타임에는 알 수 없다.
  
(Array_VS_Generic 참고)

## 배열은 제네릭 타입, 매개변수화 타입, 타입 매개변수로 사용할 수 없다.
- 앞서말한 차이로 배열과 제네릭은 잘 어울러지지 못한다.
- `new List<E>[]`, `new List<String>[]`, `new E[]` -> 컴파일할 때 제네릭 배열 생성 오류
- 오류 이유 : 타입 안전하지 않음
  - 허용한다면, 컴파일러가 자동 생성한 형변환 코드에서 런타임에 `ClassCastException`을 일으킬 수 있다.

(NotGenericArray 참고)

## 실체화 불가 타입
- 런타임에는 컴파일타임보다 타입 정보를 적게 가져가는 타입
- ex) `E`, `List<E>`, `List<String>`
- 매개변수화 타입 가운데에 실체화될 수 있는 타입은 `비한정적 와일드카드 타입`

## 배열로 형변환
- 제네릭 배열 생성 오류 or 비검사 형변환 경고
  - 대부분 E[] -> List<E>로 바꾸면 해결된다.
  - 코드가 복잡해지지만, 타입 안정성과 상호운용성이 보장된다.
  - (Chooser, ChooserGeneric 참고)

## 정리
> 배열은 공변이고 실체화 되는 반면,
> </br>제네릭은 불공변이고 타입 정보가 소거된다.
> </br> 배열은 런타임에는 타입 안전하지만 컴파일 타임에는 그렇지 않다.
> </br> 제네릭은 반대다.
> </br> 둘을 섞어 쓰다가 컴파일오류나 경고를 만나면, 먼저, 배열을 리스트로 대체해보자