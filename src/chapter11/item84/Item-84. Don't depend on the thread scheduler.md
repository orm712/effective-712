프로그램의 동작을 스레드 스케줄러에 기대지 말라
## 스레드 스케줄링 정책은 OS마다 다르다
- 그렇기 때문에, 잘 작성된 프로그램은 이러한 정책에 의존해서는 안 됨
- `정확성` 또는 `성능`이 *`스레드 스케줄러`에 따라 달라지는 프로그램*이라면, 다른 플랫폼에 `이식하기 어려움(nonportable)`
### 이식성이 좋은 프로그램을 작성하는 방법
- `실행 가능한 스레드`의 **평균적인 수**를 `프로세서 수`보다 **지나치게 많아지지 않도록** 작성해야 함
	- 이렇게 하면 `스레드 스케줄러`는 *더 이상 실행할 수 없을때까지*(*즉, 스레드들이 맡은 작업을 완료할 때 까지*) `실행 가능한 스레드들을 실행`하는 것 외에는 선택지가 남지 않음
	- 이러한 프로그램은 `다른 스케줄링 정책을 갖는 시스템`에서도 **동작이 크게 달라지지 않음**
	- 다만, 유의할 사항으로 `실행 가능한 스레드의 수`는 `전체 스레드 수`와 같지 않으며 **더 많을 수 있음**
		- 또한, `대기중인 스레드`는 **실행 가능하지 않음**
### 실행 가능한 스레드 수를 적게 유지하는 기법
- 각 `스레드`가 *유용한 작업을 수행한 뒤*, `다음 작업이 생길 때까지 대기`하도록 하면 됨
	- 스레드는 `유용한 작업`을 수행하지 않는다면, **`실행되지 않아야` 함**
- `실행자 프레임워크`를 예로 든다면, `스레드 풀의 크기`를 적절히 `조절`하고 `작업은 짧게` 유지하면 됨
	- 다만, `작업이 너무 짧을` 경우 `작업을 분배(dispatching)`하는데서 오는 **오버헤드**가 **성능을 저하**시킬 수 있음
### 바쁜 대기(busy-wait) 문제
- 스레드는 `공유 객체의 상태`가 *변경될 때까지* `반복적으로 확인`(즉, `바쁜 대기`)해서는 **안 됨**
	- `바쁜 대기`는 `스레드 스케줄러의 변덕`에 **취약**할 뿐만 아니라, `프로세서의 부하`가 **증가**해 *다른 스레드들이 수행할 수 있는* `유용한 작업의 양`이 **줄어듦**
#### 극단적인 예시 - CountDownLatch
```java
public class SlowCountDownLatch {
	private int count;
	
	public SlowCountDownLatch(int count) {
		if (count < 0)
			throw new IllegalArgumentException(count + " < 0");
		this.count = count;
	}
	public void await() {
		while (true) {
			synchronized(this) {
				if (count == 0)
					return;
			}
		}
	}
	public synchronized void countDown() {
		if (count != 0)
			count--;
	}
}
```
- 위 코드는 기존의 `CountDownLatch`를 꼬아, `await`를 `무한 루프 while`문을 사용하도록 구현한 사례임
- 저자에 따르면, 래치를 기다리는 스레드 1,000개를 만들어 자바의 `CountDownLatch`와 비교했을 때 약 **10배** 느렸다고 함
	- 실제 둘의 속도를 비교해보니, `SlowCountDownLatch`는 0.0503738초, `CountDownLatch`는 0.0167784초로 약 **3배 정도 차이**남
- 이러한 예시가 과장된 것처럼 보일 수 있으나, 하나 이상의 스레드가 *`불필요하게 실행 가능한`* 시스템은 **드물지 않음**
	- 이러한 시스템은 `성능`과 `이식성`이 **떨어질 수 있음**
### Thread.yield를 사용해 문제를 해결하려는 시도는 자제하자
- 특정 스레드가 *다른 스레드들에 비해* `CPU 시간`을 **충분히 확보하지 못해** 간신히 동작하는 프로그램에서 이를 사용할 경우 *증상히 호전될 순 있으나*, `이식성이 떨어짐`
	- 한 JVM 구현에서는 `성능을 개선`시켜준 `yield`가 *다른 JVM 구현에서는* `성능을 악화`시키거나, `아무런 영향을 미치지 않을 수` 있음
	- 특히, `Thread.yield`는 테스트할 구문도 존재하지 않음
- 따라서, *애플리케이션 구조 자체를 바꾸어* **`동시에 실행 가능한 스레드 수`를 줄이는 것**이 나음
#### Thread.yield
```java
// 출처: [Brief Introduction to Java Thread.yield() | Baeldung](https://www.baeldung.com/java-thread-yield)

public class ThreadYield {
    public static void main(String[] args) {
        Runnable r = () -> {
            int counter = 0;
            while (counter < 2) {
				//counter가 2 미만이라면, 현재 스레드의 이름을 출력한 뒤 프로세서 사용을 양보
                System.out.println(Thread.currentThread()
                    .getName());
                counter++;
                Thread.yield();
            }
        };
        new Thread(r).start();
        new Thread(r).start();
    }
	// 결과 1 ==============================
	// Thread-0
	// Thread-1
	// Thread-1
	// Thread-0
	// 결과 2 ==============================
	// Thread-0
	// Thread-0
	// Thread-1
	// Thread-1
}
```
- `java.lang.Thread`의 메서드 중 하나로, `스레드 스케줄러`에게 `현재 프로세서의 사용`을 **`양보(포기)할 의향`** 이 있음을 알려주는 `힌트`임
	- 스케줄러는 이 **`힌트를 무시할 수 있음`**
- 위 예시 코드에서 만약 이러한 `양보`가 `wait-notify`와 같이 강제되었다면, `0, 1, 0, 1`의 흐름으로 출력이 되었겠지만, **`힌트`** 이기 때문에 *실행할 때마다* **다른 결과**를 얻게 됨
- *공식 문서에 따르면*, `yield`는 *사용할 필요가 없고* *목적이 매우 명확하지 않은 이상* `사용하지 않을것을 권장`하나, `동시성 제어 구조 설계`시 `시스템 응답 개선의 일부로 사용`할 순 있음
	- 다만 이를 위해, 상세한 `프로파일링` 및 `벤치마킹`이 **수반되어야 함**을 명시함
	- [Thread (Java Platform SE 8 )](https://docs.oracle.com/javase/8/docs/api/java/lang/Thread.html#yield--)
#### 스레드 우선순위 조절?
- 위 상황에서 `스레드 우선순위`를 조절하는 방법도 있지만, 이는 *Java에서* `가장 이식성이 떨어지는 기능`으로 **위험이 따름**
	- 스레드 몇 개의 `우선순위를 조정`해 **애플리케이션의 반응 속도를 높이는 것**이 *불합리한 것은 아니나*, **드문 경우**이며 **이식성도 떨어짐**
	- *진짜 원인을 찾아 수정하기 전*에는 **같은 문제**가 **계속해서 재발**할 것임
# 핵심 정리
- `프로그램의 동작`을 *`스레드 스케줄러`에 기대어서는 안 됨*
	- `견고성(robustness)`과 `이식성`을 모두 해치는 행위임
- 동일한 이유로, `Thread.yield`와 `스레드 우선순위`에 **의존해서도 안 됨**
	- 이들은 `스레드 스케줄러`에게 제공하는 `힌트`일뿐임
- `스레드 우선순위`는 `이미 동작하는 프로그램`의 **서비스 품질 개선에 사용**할 수 있으나, `간신히 동작하는 프로그램`을 **고치는데는 써서는 안 됨**