메서드 시그니처를 신중히 설계하라
## API 설계 요령
### 메서드 이름을 신중히 지을 것
- 항상 `표준 명명 규칙(item 68)`을 따를 것
	1. `이해 가능`하고, *`같은 패키지` 내 다른 이름들*과 일관되게 지을 것
	2. `널리 받아들여지는 이름`을 쓸 것
	3. `긴 이름`은 `피할 것`
- 불확실한 경우, `Java 라이브러리 API의 지침`을 찾아볼 것
	- `Java 라이브러리`가 방대해, 일관되지 않은 이름들도 많지만 대부분 납득하여 쓰고 있음
### 편의 메서드를 너무 많이 만들지 말 것
- 클래스에 *메서드가 너무 많을 경우* 이들의 `익힘`, `사용`, `문서화`, `테스트`, `유지보수`가 힘듦
	- `인터페이스` 역시 *메서드가 너무 많으면* `구현하는 사람`과 `사용하는 사람`이 힘듦
- 클래스/인터페이스는 *각 동작에 대해* `완전한 기능을 갖춘 메서드`를 제공해야 함
- *자주 쓰이는 메서드*에 대해서만 별도의 `약칭 메서드`를 둘 것
- **확신이 서지 않으면 만들지 말 것**
### 긴 매개변수 목록은 피할 것
- 매개변수는 가급적 `4개 이하`로 둘 것
	- 그 이상이 되면 `기억하기도 힘들고`, *`많은 메서드들`이 이러할 경우* `API 문서의 도움` 없이 사용이 힘들어짐
	- *IDE가 이들을 도와줘도*, 여전히 `적은 매개변수가 나음`
- `"같은 타입"의 매개변수가 연속될 경우` 특히 힘듦
	- `순서를 기억하기도 힘들며`, *실수로 `순서가 바뀌어도`* **정상적으로 컴파일 및 실행**됨
#### 긴 매개변수 목록을 줄이는 방법
##### 1. 여러 메서드로 쪼개기
- 쪼개진 메서드들 각각은 원래 `매개변수 목록의 부분 집합`을 받음
- 자칫 *메서드가 너무 많아질 수도 있으나*, `직교성(orthogonality)을 높여` 메서드 수를 줄이는데 **도움이 될 수 있음**
	- `직교성`: `공통점이 없는 기능들`을 각각 `독립적으로 제공`하는 정도, 또는 기능이 `원자적으로 쪼개져` 제공되는 정도
	- 편의성을 높이고자 *기본 기능들을 조합한* `고수준의 기능`들을 추가해나갈수록, 메서드 갯수가 늘어날 수 있음
	- 반면, 적절히 `기본 기능`만 제공해 `클라이언트가 이들을 조합해 사용`하도록 하면 **제공할 메서드 갯수를 줄일 수 있음**
	- 이러한 `직교성`은 `API 사용자의 눈높이`와 `특정 기능들의 조합이 자주 사용되는지`와 같은 것들을 복합적으로 고려해 조절해야 함
- 좋은 예시 - `java.util.List`
	- 리스트의 *지정된 일정 부분에서* `주어진 원소`를 찾아야 할 경우
		- 이 기능을 구현하려면 `'부분 리스트의 시작'`, `'부분 리스의 끝'`, `'찾을 원소'` 3개의 원소가 필요
		- 그 대신 `List`는 *부분 리스트를 반환하는* `subList`와 *주어진 원소의 인덱스를 알려주는* `indexOf`를 제공
		- 사용자는 `이들을 조합`해 원하는 `목적 달성 가능`
##### 2. 매개변수 여러 개를 묶는 도우미 클래스 만들기
- 일반적으로 이러한 `도우미 클래스`는 `정적 멤버 클래스(item24)`로 제공됨
- 이러한 기법은, 자주 발생하는 `매개변수 시퀀스`를 독립된 `하나의 개념`으로 볼 수 있을때 권장됨
	- ex) `카드 게임`을 나타내는 클래스에 카드의 `숫자`, `무늬`를 나타내는 매개변수를 지속적으로 전달하는 경우
		- 이 둘을 묶는 `카드`라는 `도우미 클래스`를 만들어 매개변수로 전달할 경우 *API 뿐만 아니라* `클래스 내부도 깔끔`해짐
##### 3. 빌더 패턴을 메서드 호출에 응용하기
```java
class Painter {
	public static Point {
		int x
		int y
		int color // 해당 점의 색깔은 생략 가능하다고 가정
		// 세터 메서드들
		public void setX(int x) { this.x = x; }
		// ...
	}
	// 기존의 메서드
	public void PaintLine(int x1, int y1, int color1, int x2, int y2, int color2)
	// 빌더 객체를 사용한 
	public void PaintLine(Point p1, Point p2)
}
```
- 매개변수가 많고, 일부는 생략해도 될 때 도움되는 방법
1. `모든 매개변수`를 `하나로 추상화`한 객체를 정의
2. *클라이언트 측*에서 해당 객체의 `세터를 호출`해 필요한 값 설정
3. `execute` 메서드 호출해 매개변수들의 `유효성 검사` 후, 해당 객체를 넘겨 원하는 계산 수행
### 매개변수 타입으로 클래스보다 인터페이스가 더 나음(item 64)
- *매개변수로 적합한* `인터페이스`가 있다면, *구현체 말고* `해당 인터페이스를 직접 사용`할 것
	- ex) `HashMap`, `TreeMap` 대신 `Map`을 인자로 받도록 하면 이들 이외에도 `ConcurrentHashMap`와 같은 Map 구현체들도 건넬 수 있음
		- 심지어 메서드 작성 시점에서 *아직 존재하지 않는* `Map`도 받을 수 있게 됨
- `클래스로 설정`하는 것은 클라이언트에게 다음의 불편함을 유발
	1) `특정 구현체 사용을 강요`
	2) *`다른 구현체`에 존재하는* 데이터를 `메서드에 명시된 구현체`로 옮기는 `복사 비용을 발생`시킴
### boolean보다 원소 2개인 열거 타입이 나음
- 단, *메서드 이름상* `boolean 타입`을 받는게 `더 명확한 경우`는 `예외`
- `열거 타입`의 `장점`
	1. 코드의 `가독성`이 오름
	2. `선택지 추가`가 `쉬움`
- 예시
	```java
		// 온도 단위 종류를 나타내는 열거 타입
		// 원소로 화씨(FAHRENHEIT), 섭씨(CELSIUS) 보유
		public enum TemperatureScale { FAHRENHEIT, CELSIUS }

		// 온도계 클래스의 인스턴스 생성
		// 1. 화씨인지 여부를 boolean으로 정하는 경우
		Thermometer.newInstance(true) // 화씨 온도계

		// 2. 측정 단위를 열거 타입으로 정하는 경우
		Thermometer.newInstance(TemperatureScale.FAHRENHEIT) // 화씨 온도계
	```
	- `온도계 클래스(Thermometer)`의 `정적 팩터리 메서드(newInstance)`를 통해 온도계 인스턴스를 생성하는 경우
		- `boolean` 보다 `열거 타입`을 사용하는게 더 명확함
		- 또한, 추후 `Thermometer`에 *정적 메서드 추가 없이* `캘빈온도` 등 `다른 온도체계를 추가`할 수도 있음
		- 그리고 `온도 단위에 대한 의존성`을 `열거 타입 상수의 메서드` 안에 `리팩터링`해 넣을 수 있음
			```java
			public enum TemperatureScale {  
			    FAHRENHEIT {  
			        double toCelsius(double fahrenheit) {  
			            return (fahrenheit - 32) * (double) 5 / (double) 9;  
			        };  
			    },  
			    CELSIUS {  
			        double toFahrenheit(double celsius) {  
			            return (double) 5 / (double) 9 * celsius + 32;  
			        };  
			    }  
			}
			```
			- ex) `double 값`을 받아 `섭씨온도로 변환`하는 메서드를 `열거 타입 상수 각각에 정의`해둘 수 있음